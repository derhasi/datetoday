<?php
// $Id$

/**
 * @file
 *  this module provides general api functions to provide an automated stats
 *  tool for other modules, for example to count and store values of a given
 *  database table
 */

/**
 * Updates or create stats for the given stats type, eventually specified with
 * a single subject to update for, or a new value for the given subject, to
 * avoid a maybe performance lack by
 *
 * @param $type
 *  stats type - defined by module or stored in database
 * @param $subject
 *  (optional) specific subject to rebuild the value for a specific subject
 * @param $new_value
 *  (optional) value that was instantly added, needed to create data updates,
 *  without doing a rebuild
 * @param $return_values
 *  (optional) default: FALSE, on TRUE this will return the derived values as
 *  an array. Data won't be stored.
 * @return
 *  Returns FALSE if run was not successfull.
 */
function stats_run($type, $subject = NULL, $new_value = NULL, $return_values = FALSE) {
  $types = stats_types();
  if (!isset($types[$type])) {
    watchdog('stats', 'Stats type %type is not defined.', array('%type' => $type), WATCHDOG_ERROR);
    return FALSE;
  }
  $type = $types[$type];

  // Callback definitions
  $callback_load = $type['storage']['callback']['load'];
  $callback_write = $type['storage']['callback']['write'];
  $callback_derivation = $type['derivation']['callback'];
  $callback_d_and_s = $type['derivation & storage']['callback'];

  // TYPE + SUBJECT + NEW_VALUE
  if (isset($new_value)) {
    // Derive plus store
    if (!$return_values && isset($callback_d_and_s['add'])) {
      return $callback_d_and_s['add']($type, $subject, $new_value);
    }
    // Derive then store
    elseif ($callback_load && ($callback_write || $return_values) && isset($callback_derivation['add'])) {
      // Get old values
      $old_values = $callback_load($type, $subject, $new_value);
      // Derive new values
      $values = $callback_derivation['add']($type, $old_values, $subject, $new_value);
      if ($return_values) return $values;
      return $callback_write($type, $values, $subject, $new_value);
    }
  }

  // TYPE + SUBJECT: Fall back on only subject level
  if (isset($subject)) {
    // Derive plus store
    if (!$return_values && isset($callback_d_and_s['rebuild_single'])) {
      return $callback_d_and_s['rebuild_single']($type, $subject);
    }
    // Derive then store
    elseif (($storage || $return_values) && isset($callback_derivation['rebuild_single'])) {
      // Get old values
      $old_values = $callback_load($type, $subject);
      // Derive new values
      $values = $callback_derivation['rebuild_single']($type, $old_values, $subject);
      if ($return_values) return $values;
      return $callback_write($type, $values, $subject);
    }
  }

  // TYPE: fall back on no-subject level

  // Derive plus store
  if (!$return_values && isset($callback_d_and_s['rebuild_batch'])) {
    return $callback_d_and_s['rebuild_batch']($type);
  }
  // Derive then store
  elseif (($storage || $return_values) && isset($callback_derivation['rebuild_batch'])) {
    // Get old values
    $old_values = $callback_load($type);
    // Derive new values
    $values = $callback_derivation['rebuild_batch']($type, $old_values);
    if ($return_values) return $values;
    return $callback_write($type, $values);
  }
  watchdog('stats', 'There could not be found a valid callback for type %type, subject $subject, new value %new_value (return value: %return_values)', array('%type' => $type['type'], '%subject' => $subject, '%new_value' => $new_value, '%return_values' => $return_values), WATCHDOG_ERROR);
  return FALSE;
}

/**
 * Queues the creation of stats runs.
 *
 * job_queue?
 */
function stats_queue_run($type, $subject = NULL, $new_value = NULL) {

}

/**
 * Get all stats definitions.
 * @return
 *   Array of type definitions
 */
function stats_types() {
  static $stats_types;
  if (isset($stats_types)) return $stats_types;
  // Avoids two types with same 'type' value.
  $invoked = module_invoke_all('stats_info');
  $stats_types = array();
  foreach ($invoked as $key => $type) {
    // Avoid missing 'type' definition
    if (!isset($type['type'])) {
      $type['type'] = $key;
      $stats_types[$key] = $type;
    }
    else {
      $stats_types[$type['type']] = $type;
    }
  }

  // Let modules alter type definitions.
  drupal_alter('stats', $stats_types);

  // TODO: additional handling for building views data & default values.

  return $stats_types;
}
